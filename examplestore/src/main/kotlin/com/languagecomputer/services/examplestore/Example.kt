package com.languagecomputer.services.examplestore

import com.fasterxml.jackson.annotation.JsonIgnore
import com.google.common.base.Joiner
import com.google.common.collect.Lists
import com.languagecomputer.services.ontology.ConceptClass
import com.languagecomputer.services.ontology.SimpleAttributeRecord
import com.languagecomputer.services.util.Digest
import java.util.*
import java.util.stream.Collectors

/**
 * List of Example objects.
 */
class ExampleList @JvmOverloads constructor(val examples: List<Example>,
                                            val sort: SortMethod = SortMethod.ALREADY_SORTED
) {
  enum class SortMethod {
    DOCUMENT_SORT,
    ID_SORT,
    ALREADY_SORTED
  }
}

/**
 * An example, as generated by an extractor, classifier, human annotator, or external system.
 */
open class Example(val concept: String?,
                   // One of predicate, entity, etc...
                   val conceptClass: ConceptClass?,
                   // The set of extractor versions which identified this example as a positive
                   val extractorVersions: MutableSet<String>?,
                   // Human Annotated value for the example
                   var humanCall: ExampleCall?,
                   private val properties: MutableMap<String?, String?> = HashMap(),
                   // Generally the sentence (or group of sentences)
                   val context: String,
                   // typically the ID of the trigger associated with this example
                   val exampleID1: String?,
                   val corefID1: String?,
                   val exampleID2: String?,
                   val corefID2: String?,
                   val attributeValue: String?,
                   val documentID: String? = NULL_STRING_FIELD,
                   // 0-based sentence index (in Document object) of beginning of context
                   val sentenceNumber: Int = -1,
                   val sentenceNumber2: Int = -1, // This is non-negative ONLY if there are more than one sentences involved in the example.
                   // 0-based token offset of 1st span (e.g. trigger) starting at the beginning of sentence of the context
                   val startToken: Int = -1,
                   // Number of tokens in the span
                   val tokenLength: Int = -1,
                   // 0-based token offset of 2nd span starting at the beginning of sentence of the context
                   val startToken2: Int = -1,
                   val tokenLength2: Int = -1,
                   // 0-based start char offsets in the sentence for each token in the span
                   val tokenStartChars: List<Int>?) {

  var sentenceID: String? = null

  var timeStamp: Long = 0

  @JsonIgnore
  fun getTime(): Date {
    return Date(timeStamp)
  }

  @JsonIgnore
  fun setTime(d: Date?) {
    timeStamp = if(d == null) {
      0
    } else {
      d.getTime()
    }
  }

  fun getProperties(): Map<String?, String?> {
    return properties.filterKeys { it != null }.filterValues { it != null }
  }

  @get:JsonIgnore
  val trigger: String
    get() = if(properties.containsKey(TRIGGER)) properties[TRIGGER]!! else ""

  /**
   * Remove a property from the example.
   * @return the property value being removed, or null if the property did not exist
   */
  fun removeProperty(propName: String?): String? {
    return properties.remove(propName)
  }

  /**
   * Adds a value of the properties map, the property map supports
   * an arbitrary mapping of string value pairs, for example to provide a sentenceID
   * @param propName
   * @param propValue
   */
  fun addProperty(propName: String?, propValue: String?) {
    properties[propName] = propValue
  }

  /**
   * @return Helper method returns true if a human has keyed any facet on this example, false otherwise
   */
  fun humanKeyed(): Boolean {
    return humanCall != null && humanCall != ExampleCall.UNKEYED
  }

  /**
   * Sets humancall property on the example object
   * Generally one of positive, negative, unkeyed, or punt
   * @param humanCall
   */
  fun key(humanCall: ExampleCall?) {
    this.humanCall = humanCall
  }

  override fun toString(): String {
    return "Example{" +
            "concept='" + concept + '\'' +
            ", conceptClass=" + conceptClass +
            ", context='" + context + '\'' +
            ", id='" + iD + '\'' +
            ", humanCall='" + humanCall + '\'' +
            ", exampleID1='" + exampleID1 + '\'' +
            ", exampleID2='" + exampleID2 + '\'' +
            ", corefID1='" + corefID1 + '\'' +
            ", corefID2='" + corefID2 + '\'' +
            ", attributeValue='" + attributeValue + '\'' +
            ", documentID='" + documentID + '\'' +
            ", sentenceNumber=" + sentenceNumber +
            ", sentenceNumber2=" + sentenceNumber2 +
            ", startToken=" + startToken +
            ", tokenLength=" + tokenLength +
            ", startToken2=" + startToken2 +
            ", tokenLength2=" + tokenLength2 +
            ", extractors=" + extractorVersions +
            ", tokens=" + tokenStartChars +
            ", properties=" + properties.entries.stream().map { entry: Map.Entry<String?, String?> -> entry.key.toString() + ": " + entry.value }.collect(Collectors.joining(", ")) +
            '}'
  }

  override fun equals(other: Any?): Boolean {
    if(this === other) return true
    if(other !is Example) return false
    return iD == other.iD
  }

  override fun hashCode(): Int {
    return iD.hashCode()
  }

  fun nullProtect(obj: Any?): Any {
    return obj ?: NULL_STRING_FIELD
  }

  fun normalize(obj: Any): Any {
    if(obj == NULL_STRING_FIELD) return obj
    val strParts = obj.toString().split(":".toRegex()).toTypedArray()
    if(strParts[0].matches(Regex("nu?"))) {
      val parts = arrayOfNulls<Any>(strParts.size)
      for(i in strParts.indices) {
        parts[i] = strParts[i]
      }
      parts[1] = java.lang.Double.valueOf(strParts[1])
      return parts.joinToString(":")
    }
    return obj
  }// These are roles with the parent in another sentence (or not backed by a document).

  /**
   * Returns a unique ID for the example object, generally just the MD5 Digest
   * @return
   */
  var iD: String? = null
    get() {
      if(field == null) {
        if(exampleID1 != null || corefID1 != null) {
          val builder = StringBuilder("xdoc:")
          val digest = getDigest(nullProtect(documentID) as String, concept, sentenceNumber, startToken, tokenLength, -1, -1, getHeadToken())
          val join = Joiner.on(':').join(digest, nullProtect(exampleID1), nullProtect(corefID1), nullProtect(exampleID2), nullProtect(corefID2),
                                         normalize(nullProtect(attributeValue)))
          field = builder.append(Digest.MD5.digestString(join)).toString()
        } else {
          // Note: sentence2 doesn't need to be here, since the startToken and tokenLength are relative to only the first sentence start
          // HOWEVER, this means that given two adjacent sentences A and B. The ID will be different for an identical span on B that ONLY
          //   includes sentence B and one that also includes sentence A. For now, I'm going to say this is okay.
          field = getDigest(documentID, concept, sentenceNumber, startToken, tokenLength, startToken2, tokenLength2, getHeadToken())
          if(startToken < 0 && startToken2 >= 0) {
            // These are roles with the parent in another sentence (or not backed by a document).
            // NOTE: I'm not sure about this (MM)
            field = "$iD:${properties[TRIGGER_ID]}"
          }
        }
      }
      return field
    }// Prevents multiple examples on the same span from appearing in different splits.

  fun getHeadToken(): Int {
    return try {
      Integer.valueOf(properties.get(HEAD_TOKEN))
    } catch (e: IllegalArgumentException) {
      -1
    }
  }

  /**
   *
   * @return
   */
  @get:JsonIgnore
  val splitID: String
    get() {
      val base = if(isDocumentBacked) // Prevents multiple examples on the same span from appearing in different splits.
        "$documentID:$sentenceNumber".hashCode() else iD.hashCode()
      return "" + (base % 10 + 10) % 10
    }

  /**
   * If this example object is a role, returns information about the linked parent ID, probably an event
   * @return
   */
  @get:JsonIgnore
  val roleParentID: String?
    get() = if(properties[TRIGGER_ID] != null) {
      properties[TRIGGER_ID]
    } else getDigest(nullProtect(documentID) as String, concept!!.replace("#.*".toRegex(), ""), sentenceNumber, startToken, tokenLength, -1, -1)

  fun hasDocumentSpan(): Boolean {
    return isDocumentBacked && startToken >= 0
  }

  val isDocumentBacked: Boolean
    get() = documentID != NULL_STRING_FIELD && sentenceNumber >= 0

  companion object {
    const val NULL_STRING_FIELD = "__NULL__"
    // trigger string
    const val TRIGGER = "trigger"
    const val TEXT2 = "text2"
    // 0-based token offset of the head
    const val HEAD_TOKEN = "headToken"
    const val LATEST = "latest"
    // 0-based token index (in Document object) of beginning of sentence of the context
    const val SENTENCE_START_TOKEN = "sentence_start_token"
    const val KEYDATE = "keydate"
    const val USER = "user"
    const val OLD_SPAN = "oldSpan"
    const val CHAIN_ID = "chainID"
    const val EXTRACTOR_SOURCE = "ExtractorSource"
    const val SPLIT_PROPERTY = "10split"

    // the id of the trigger if this is a role example (or event attribute, etc.)
    const val TRIGGER_ID = "trigger_id"

    /**
     * Returns an MD5 hash for the example object
     * @param documentID
     * @param concept
     * @param sentenceNumber
     * @param startToken
     * @param tokenLength
     * @param startToken2
     * @param tokenLength2
     * @return
     */
    @JsonIgnore
    fun getDigest(documentID: String?, concept: String?, sentenceNumber: Int, startToken: Int, tokenLength: Int, startToken2: Int, tokenLength2: Int): String {
      return getDigest(documentID, concept, sentenceNumber, startToken, tokenLength, startToken2, tokenLength2, -1)
    }

    fun getDigest(
      documentID: String?,
      concept: String?,
      sentenceNumber: Int,
      startToken: Int,
      tokenLength: Int,
      startToken2: Int,
      tokenLength2: Int,
      @Suppress("UNUSED_PARAMETER") ignored: Int,
    ): String {
      val join: String =
//     if (headToken >= 0) {
//        Joiner.on(':').join(documentID, concept ?: "", sentenceNumber, headToken)
//      } else
      if(tokenLength2 <= 0) {
        Joiner.on(':').join(documentID, concept ?: "", sentenceNumber, startToken, tokenLength)
      } else {
        Joiner.on(':').join(documentID, concept
                ?: "", sentenceNumber, startToken, tokenLength, startToken2, tokenLength2)
      }
      return Digest.MD5.digestString(join)
    }


      fun getAttributeValueType(ex: Example?): SimpleAttributeRecord.AttributeValueType? {
          if(ex?.attributeValue == null || ex.attributeValue.isEmpty() || !ex.attributeValue.contains(":")) {
              return null
          }
          val parts = ex.attributeValue.split(":".toRegex()).toTypedArray()
          return when(parts[0]) {
              "b" -> SimpleAttributeRecord.AttributeValueType.BOOLEAN
              "n" -> if(parts[0].contains(".")) SimpleAttributeRecord.AttributeValueType.DOUBLE else SimpleAttributeRecord.AttributeValueType.INTEGER
              "nu" -> SimpleAttributeRecord.AttributeValueType.DOUBLE_UNITS
              "s" -> SimpleAttributeRecord.AttributeValueType.STRING
              "e" -> SimpleAttributeRecord.AttributeValueType.ENUM
              "t" -> SimpleAttributeRecord.AttributeValueType.TIMEX
              "es" -> SimpleAttributeRecord.AttributeValueType.ENUMSET
              else -> {
                  System.err.println("Unknown attribute type for attributeValue: " + ex.attributeValue)
                  throw IllegalArgumentException("Invalid attribute type")
              }
          }
      }

      fun getAttributeValue(ex: Example?, valueType: SimpleAttributeRecord.AttributeValueType?): Any? {
          return if(ex?.attributeValue == null) {
              null
          } else getAttributeValue(ex.attributeValue, valueType)
      }

      fun getAttributeValue(attributeValue: String?, valueType: SimpleAttributeRecord.AttributeValueType?): Any? {
          if(attributeValue == null || attributeValue.isEmpty() || !attributeValue.contains(":") || valueType == null) {
              return null
          }
          val parts = attributeValue.split(":".toRegex()).toTypedArray()
          return when(valueType) {
              SimpleAttributeRecord.AttributeValueType.BOOLEAN -> java.lang.Boolean.valueOf(parts[1])
              SimpleAttributeRecord.AttributeValueType.INTEGER -> Integer.valueOf(parts[1])
              SimpleAttributeRecord.AttributeValueType.DOUBLE -> java.lang.Double.valueOf(parts[1])
              SimpleAttributeRecord.AttributeValueType.DOUBLE_UNITS -> parts[1] // Should be parsable as <double><space><string>
              SimpleAttributeRecord.AttributeValueType.STRING -> parts[1]
              SimpleAttributeRecord.AttributeValueType.ENUM -> parts[1]
              SimpleAttributeRecord.AttributeValueType.TIMEX -> parts[1]  // Should be parsable as timex
              SimpleAttributeRecord.AttributeValueType.ENUMSET -> Lists.newArrayList(*parts[1].split(",".toRegex()).toTypedArray())
          }
      }
  }

}
